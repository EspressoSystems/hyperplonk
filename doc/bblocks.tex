\newcommand{\bcube}[1]{B_{#1}}
\newcommand{\bdp}[2]{{\mathcal{F}}_{#1}^{(\le{#2})}}   % bounded degree polynomials
\newcommand{\perm}{\pi} % permutation
\newcommand{\addr}{\mathsf{addr}} % lookup addresses
\newcommand{\eqpoly}{eq}
\newcommand{\sidpoly}{s_{\text{id}}}
\newcommand{\spermpoly}{s_{\perm}}
\newcommand{\decode}[1]{[#1]}
\newcommand{\nxt}[1]{\mathtt{nxt}_{#1}}
\newcommand{\sps}[1]{k_{#1}} % sparseness index for the next polynomial

% Indexed relations
\newcommand{\idxR}{\mathbbm{i}} % relation index
\newcommand{\instR}{\mathbbm{x}} % relation instance
\newcommand{\witR}{\mathbbm{w}} % relation witness

% Building block relations
\newcommand{\RPERM}{{\mathcal{R}}_{\text{PERM}}}
\newcommand{\RZERO}{{\mathcal{R}}_{\text{ZERO}}}
\newcommand{\RSUM}{{\mathcal{R}}_{\text{SUM}}}
\newcommand{\RPROD}{{\mathcal{R}}_{\text{PROD}}}
\newcommand{\RLOOKUP}{{\mathcal{R}}_{\text{LOOKUP}}}
\newcommand{\RPUB}{{\mathcal{R}}_{\text{PUB}}}

% Poly IOPs
\newcommand{\prover}{\mathcal{P}} 
\newcommand{\verifier}{\mathcal{V}}
\newcommand{\indexer}{\mathcal{I}}

% Sumchecks
\newcommand{\chal}[1]{\rho_{#1}} % random challenges


\subsection{Relations}
Let $\bcube{n} \deq \zo^{n} \subseteq \FF^n$ be the boolean hypercube. Let $\bdp{n}{d}$
be the set of multivariate polynomials in $\FF[X_1, \dots, X_n]$ where the degree 
in each variable is at most $d$. We define the following important relations.

\begin{definition}[Sumcheck relation]\label{def:rsum}
    The relation $\RSUM$ is the set of all tuples $(\instR, \witR) = 
    ((n, d, s), f)$ where $f \in \bdp{n}{d}$ and $\sum_{\xv \in \bcube{n}} f(\xv) = s$.
\end{definition}

\begin{definition}[Zerocheck relation]\label{def:rzero}
    The relation $\RZERO$ is the set of all tuples $(\instR, \witR) =
    ((n, d), f)$ where $f \in \bdp{n}{d}$ and $f(\xv) = 0$ for all $\xv \in \bcube{n}$.
\end{definition}

\begin{definition}[Product-check relation]
    The relation $\RPROD$ is the set of all tuples $(\instR, \witR) =
    ((n, d, s), f)$ where $f \in \bdp{n}{d}$ and $\prod_{\xv \in \bcube{n}} f(\xv) = s$.
\end{definition}

\begin{definition}[Permutation relation]\label{def:rperm}
    The indexed relation $\RPERM$ is the set of triples $(\idxR, \instR, \witR)=
    ((n, d, \perm), \bot, (f, g))$ where $f, g \in \bdp{n}{d}$, $\perm : \bcube{n} \rightarrow \bcube{n}$
    is a permutation, and $g(\xv) = f(\perm(\xv))$ for all $\xv \in \bcube{n}$.
\end{definition}

\begin{definition}[Lookup relation]\label{def:rlookup}
    The indexed relation $\RLOOKUP$ is the set of triples $(\idxR, \instR, \witR)=
    ((n, d_t, d_f, t), \bot, (f, \addr))$, where $t \in \bdp{n}{d_t}$, $f \in \bdp{n}{d_f}$,
    and $\addr: \bcube{n} \rightarrow \bcube{n}$ is an address map such that 
    $f(\xv) = t(\addr(\xv))$ for all $\xv \in \bcube{n}$.
\end{definition}

\begin{remark}
    We can extend the lookup relation $\RLOOKUP$ to an \emph{online lookup relation}
    where the table polynomial $t(\xv)$ is part of the witness $\witR$ 
    instead of part of the index $\idxR$.
\end{remark}

\subsection{Constructions}
We specify the Polynomial Interactive Oracle Proofs (PIOPs) protocols for the above relations.

\paragraph*{Sending witness by default.}
In the following context, we assume without loss of generality that the witness polynomials 
are always sent as oracles to the verifier before the online interactive phase begins.

\subsubsection*{PIOP for $\RSUM$.} We construct a PIOP for 
the relation $\RSUM$. It is basically a reformulation to the sumcheck protocol
of~\cite{LFKN92}.
The prover $\prover$ takes as input an instance $\instR = (n, d, s)$,
and witness $\witR = f$; the verifier $\verifier$ takes as input the 
instance $\instR = (n, d, s)$.

\textbf{Interactive phase.} 
Let $\chal{i} \in \FF$ $(1 \le i \le n)$ denote the public coin challenge
of the verifier in round $i$.
For each round $i \in [n]$, the prover $\prover$ computes a 
degree-$d$ univariate polynomial
\[
      s_i(X_i) \deq 
      \sum_{ (x_{i+1}, \dots, x_{n}) \in \zo^{n-i} } 
      f(\chal{1}, \dots, \chal{i-1}, X_i, x_{i+1}, \dots, x_n) \,.
\]
and sends the (univariate) oracle $s_i$ to the verifier.

\textbf{Query phase.}
Define $s_0(\chal{0}) = s$. For each $i \in [n]$, the verifier makes oracle queries to $s_i(X_i)$ on points
$\{0, 1, \chal{i} \}$ and checks that
\[
  s_{i-1}(\chal{i-1}) = s_{i}(0) + s_{i}(1) \,.  
\]
The verifier further queries $f$ on point $(\chal{1}, \dots, \chal{n})$ and checks that
\[
  s_n(\chal{n}) = f(\chal{1}, \dots, \chal{n}).  
\]

\subsubsection*{PIOP for $\RZERO$.} 
We construct a PIOP for the relation $\RZERO$.
The prover $\prover$ takes as input an instance $\instR = (n, d)$,
and witness $\witR = f$; the verifier $\verifier$ takes as input the 
instance $\instR = (n, d)$. We define equality checking polynomial
\[
  \eqpoly(\xv, \yv) \deq \prod_{i=1}^{n} (x_iy_i + (1-x_i)(1-y_i)) \,,
\]
and observe that $(\instR, \witR) = ((n,d), f) \in \RZERO$ if and only if
\[
  g(\yv) \deq \sum_{\xv \in \bcube{n}} f(\xv) \cdot \eqpoly(\xv, \yv)  
\]
is identically zero. Hence it is sufficient to check that $g(\rv) = 0$
for a random vector $\rv \in \FF^n$. The PIOP is as follows:
\begin{itemize}
    \item The verifier $\verifier$ sends $\prover$ a random vector $\rv \in \FF^{n}$.
    \item The prover $\prover$ and the verifier $\verifier$ run one PIOP execution
    for $\RSUM$ with $\instR = (n, d+1, 0)$ and $\witR = \hat{f}$, where
    \[
      \hat{f}(\xv) \deq f(\xv) \cdot \eqpoly(\xv, \rv) 
    \]
    is a polynomial in $\bdp{n}{d+1}$.
    We emphasize that $\hat{f}$ was implicitly sent before the interactive phase of the sub-PIOP starts,
    as $\verifier$ already has the oracle access to $f$ and $\eqpoly$ in the beginning.
\end{itemize}

\subsubsection*{PIOP for $\RPROD$.}
We construct a PIOP for the relation $\RPROD$.
The PIOP extends the protocol in Section 5
of~\cite{SL20} to further support product checks on polynomials that are not multilinear.
The prover $\prover$ takes as input an instance $\instR = (n, d, s)$
and a witness $\witR = f \in \bdp{n}{d}$; the verifier $\verifier$
takes as input the instance $\instR = (n, d, s)$.

\textbf{Interactive phase.} 
\begin{itemize}
    \item The prover $\prover$ computes and sends a \emph{multilinear} polynomial oracle 
    $\hat{f} \in \bdp{n+1}{1}$ such that for all $\xv \in \bcube{n}$, it holds that
    \[
      \hat{f}(0, \xv) = f(\xv), \qquad \qquad \hat{f}(1, \xv) = \hat{f}(\xv, 0) \cdot \hat{f}(\xv, 1)\,.
    \]
    \item The prover $\prover$ and the verifier $\verifier$ run (in parallel) the interactive phase 
    of two $\RZERO$'s PIOP executions:
    \begin{itemize}
        \item The $1$st execution is with $\instR = (n, 2)$ and $\witR = g \in \bdp{n}{2}$ where
            \[
                g(\xv) \deq \hat{f}(1, \xv) - \hat{f}(\xv, 0) \cdot \hat{f}(\xv, 1) \,.
            \]
            
        \item The $2$nd execution is with $\instR = (n, d)$ and $\witR = h \in \bdp{n}{d}$ where
            \[
                h(\xv) \deq  \hat{f}(0, \xv) - f(\xv) \,.
            \]
    \end{itemize}
    We emphasize that $g$ and $h$ were \emph{``virtually sent''} before the interactive phase of the sub-PIOPs start,
    as $\verifier$ already has oracle accesses to $\hat{f}$ and $f$.
\end{itemize}

\textbf{Query phase.}
\begin{itemize}
    \item The verifier $\verifier$ queries $\hat{f}$ on point $(1, \dots, 1, 0)$ and checks that
        $\hat{f}(1,\dots, 1, 0) = s$.
    % \item The verifier $\verifier$ queries $\hat{f}$ and $f$ on a random vector $\rv \in \FF^n$,
    %     and checks that $\hat{f}(0, \rv) = f(\rv)$.
    \item The verifier $\verifier$ runs (in parallel) the query phase of the two sub-PIOPs 
    for relation $\RZERO$ (specified in the interactive phase).
\end{itemize}

\begin{remark}
    For the special case where $f$ is multilinear, as noted by~\cite{SL20},
    one can save the zero-check sub-PIOP for polynomial $h(\xv) \deq \hat{f}(0, \xv) - f(\xv)$. 
    This is because $\hat{f}(0, \xv)$ and $f(\xv)$ are identical polynomials, 
    thus by Schwartz-Zippel lemma, it suffices to check that $f$ and $\hat{f}(0, \xv)$
    have the same evaluation outputs on a random vector $\rv \in \FF^n$.
\end{remark}

\subsubsection*{PIOP for $\RPERM$.}
We construct a PIOP for the indexed relation $\RPERM$.
The construction makes use of the technique in~\cite{GWC19} that 
transforms a permutation relation to a product relation.
The indexer $\indexer$ takes as input an index $\idxR = (n, d, \perm)$;
the prover $\prover$ takes as input the index $\idxR = (n, d, \perm)$,
a witness $\witR = (f, g)$, and the ouput oracles from $\indexer$;
the verifier $\verifier$ takes as input the instance $\instR = \bot$ and 
the indexer oracles.

\textbf{Preprocessing phase.}
\begin{itemize}
    \item The indexer computes two polynomials $\sidpoly, \spermpoly \in \bdp{n}{1}$ such that
    for all $\xv \in \bcube{n}$, it holds that 
    \[
        \sidpoly(\xv) = \decode{\xv}, \qquad\qquad \spermpoly(\xv) = \decode{\perm(\xv)}\,,
    \]
    where $\decode{\xv}$ denotes the decoding from a binary vector $\xv \in \bcube{n}$
    to a field element $y \in \FF$, that is, $\decode{\xv} = \sum_{i=1}^{n} \xv_i \cdot 2^{i-1}$.
    \item The indexer outputs the oracles $\sidpoly, \spermpoly$.
\end{itemize}

\textbf{Interactive phase.} 
\begin{itemize}
    \item The verifier $\verifier$ sends random challenges $\beta, \gamma \in \FF$.
    \item The prover $\prover$ and the verifier $\verifier$ run (in parallel) the interactive phase 
    of two $\RPROD$'s PIOP executions:
        \begin{itemize}
            \item the $1$st execution is with instance $\instR = (n, d, s)$ and
                witness $\witR = v_{f} \in \bdp{n}{d}$, where 
                $
                    s = \prod_{\xv\in\bcube{n}} (f(\xv) + \beta \sidpoly(\xv) + \gamma)
                $ and
                \[
                    v_{f}(\xv) \deq f(\xv) + \beta \sidpoly(\xv) + \gamma \,;
                \]
            \item the $2$nd execution is with instance $\instR = (n, d, s)$ and 
                witness $\witR = v_{g} \in \bdp{n}{d}$, where 
                \[
                    v_{g}(\xv) \deq g(\xv) + \beta \spermpoly(\xv) + \gamma \,.
                \]
        \end{itemize}
        We emphasize that $v_{f}, v_{g}$ were \emph{``virtually sent''} before the interactive phases of the sub-PIOPs start,
        as $\verifier$ already has the oracle accesses to $f, g, \sidpoly, \spermpoly$.
\end{itemize}

\textbf{Query phase.}
The verifier $\verifier$ runs (in parallel) the query phase of the two $\RPROD$ PIOP 
executions specified above.

\subsubsection*{PIOP for $\RLOOKUP$.} 
We construct a PIOP for the indexed relation $\RLOOKUP$.
The construction draws inspiration from the technique in~\cite{GW20} that 
transforms a lookup relation to a (special) product relation.
The indexer $\indexer$ takes as input an index $\idxR = (n, d_f, d_t, t)$;
the prover $\prover$ takes as input the index $\idxR$, instance $\instR = \bot$,
witness $\witR = (f, \addr)$, and the ouput oracles from $\indexer$;
the verifier $\verifier$ takes as input the instance $\instR = \bot$ and 
the indexer oracles.

\begin{lemma}
    For all $n \in \NN$, there exists an algebraic map
    \[
      \nxt{n}(\xv) \deq (f_{1}(\xv), \dots, f_{n}(\xv))  
    \] such that 
    \begin{itemize}
        \item let $N \deq 2^n$, the list of $n$-dimensional points
            \[
              (0^n, \nxt{n}(0^n), \nxt{n}^{1}(0^n), \dots, \nxt{n}^{N-1}(0^n))
            \]
            travels through all of the $N$ points in the boolean hypercube $\bcube{n}$.
            Here $\nxt{n}^{i}(0^n)$ denote composing the map $\nxt{n}(\cdot)$ for $i$ times
            on input vector $0^n$;
        \item $\nxt{n}(\xv)$ can be evaluated in $O(n)$ time;
        \item the product polynomial
            \[
                g_n(\xv) \deq \prod_{i=1}^{n} f_{i}(\xv)
            \] is an $n$-variate polynomial where the degree in each variable is at most $\sps{n}$.
            Here $\sps{n} = 2 \text{ or } 4$.
    \end{itemize}
\end{lemma}
\binyi{TODO: double-check if $\sps{n} = 2 \text{ or } 4$ or $\sps{n} = 3 \text{ or } 5$.}

\textbf{Preprocessing phase.}
The indexer outputs the oracles $t \in \bdp{n}{d_t}$, $\nxt{n} \in \bdp{n,n}{\sps{n}}$,
and $\nxt{n+1} \in \bdp{n+1,n+1}{\sps{n+1}}$.\footnote{We can also let the verifier 
compute $\nxt{n}$ and $\nxt{n+1}$ herself as the polynomials can be evaluated in $O(n)$ time.}

\textbf{Interactive phase.} 
\begin{itemize}
    \item The prover $\prover$ computes and sends a polynomial oracle $h \in \bdp{n+1}{1}$ ``sorted'' from $f$ and $t$.
        More precisely, let $N \deq 2^n$, define vectors
        \[
            \vec{f} \deq (f(0^n), f(0^{n-1}, 1), \dots, f(1^n) )\,, \qquad 
            \vec{t} \deq (t(0^n), t(\nxt{n}(0^n)), \dots, t(\nxt{n}^{N-1}(0^n))) 
        \]
        and let $\vec{h} \in \FF^{2N}$ denote the sorted version of $(\vec{f}, \vec{t})$ according to $\vec{t}$.
        (More precisely, we initialize $\vec{h}$ to $\vec{t}$, and 
        insert each element in $\vec{f}$ to the right of an element in $\vec{h}$ that has identical values.)
        The polynomial $h$ interpolates the vector $\vec{h}$ so that for all $i \in [2N]$,
        it holds that
        \[
            \vec{h}_i = h(\nxt{n+1}^{i-1}(0^{n+1})) \,.
        \]
        
    \item The verifier $\verifier$ sends random challenges $\beta, \gamma \in \FF$.
    
    \item The prover $\prover$ and the verifier $\verifier$ run (in parallel) the interactive phase 
    of two $\RPROD$'s PIOP executions:
        \begin{itemize}
            \item the $1$st execution is with instance $\instR = (n+1, \sps{n+1}, s)$ and
                witness $\witR = \hat{h} \in \bdp{n+1}{\sps{n+1}}$, where 
                \[
                    \hat{h}(\xv) \deq \gamma(1+\beta) + h(\xv) + \beta \cdot h(\nxt{n+1}(\xv)) \,,
                \] and $s = \prod_{\xv\in\bcube{n+1}} \hat{h}(\xv)$;
                
            \item let $d \deq \max(d_f, d_t \sps{n})$, the $2$nd execution is with instance 
                $\instR = (n+1, d, s)$ and 
                witness $\witR = g \in \bdp{n+1}{d}$, where $g$ is defined to be 
                \[
                    g(x_1, \yv) \deq (1-x_1) \cdot \left[(1+\beta)(\gamma + f(\yv))\right]
                                    + x_1 \cdot \left[\gamma(1+\beta) + t(\yv) + \beta \cdot t(\nxt{n}(\yv))\right]\,.
                \]
                We note that for all $\yv \in \bcube{n}$, it holds that
                \[
                    g(0, \yv) \deq (1+\beta)(\gamma + f(\yv)), \qquad 
                    g(1, \yv) \deq \gamma(1+\beta) + t(\yv) + \beta \cdot t(\nxt{n}(\yv)) \,.
                \]
        \end{itemize}
        We emphasize that $\hat{h}$ and $g$ were \emph{``virtually sent''} before the interactive phases of the sub-PIOPs start,
        as $\verifier$ already has oracle accesses to $h$, $\nxt{n+1}$, $f$, $t$, $\nxt{n}$.
\end{itemize}

\textbf{Query phase.}
The verifier $\verifier$ runs (in parallel) the query phase of the two $\RPROD$ PIOP 
executions specified above.

\subsection{Batching multiple zero-checks}\label{sec:batchrzero}
We construct a PIOP that proves multiple instances of relation $\RZERO$.
The prover $\prover$ takes as input an extended instance $\instR = (n, d_1, \dots, d_m)$,
and an extended witness $\witR = (f_1, \dots, f_m)$ where $f_i \in \bdp{n}{d_i}$ $(1 \le i \le m)$; 
the verifier $\verifier$ takes as input the instance $\instR = (n, d_1, \dots, d_m)$.
The goal is to prove that for all $i \in [m]$, it holds that $((n, d_i), f_i) \in \RZERO$.

Define $d \deq \max(d_1, \dots, d_m)$, the PIOP is as follows: 
(Recall that we assume without loss of generality that the witness polynomials 
are always sent as oracles to the verifier before the online interactive phase begins.)
\begin{itemize}
    \item The verifier $\verifier$ sends $\prover$ a random challenge $\alpha \in \FF$.
    \item The prover $\prover$ and the verifier $\verifier$ run one PIOP execution
    for $\RZERO$ with $\instR = (n, d)$ and $\witR = \hat{f} \in \bdp{n}{d}$, where
    \[
      \hat{f}(\xv) \deq f_1(\xv) + \alpha f_2(\xv) + \dots + \alpha^{m-1} f_m(\xv)
    \]
    We emphasize that $\hat{f}$ was implicitly sent before the interactive phase of the sub-PIOP starts,
    as $\verifier$ already has oracle accesses to $f_1, \dots, f_m$.
\end{itemize}
