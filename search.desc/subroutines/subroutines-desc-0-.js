searchState.loadedDescShard("subroutines", 0, "Takes as input a struct, and converts them to a series of …\nBatch proofs\nCommitments\nPolynomial Evaluation\nPolynomial input domain\nPolynomial and its associated types\nThis trait defines APIs for polynomial commitment schemes. …\nProofs\nProver parameters\nProver parameters\nStructured reference string\nAPI definitions for structured reference string\nVerifier parameters\nVerifier parameters\nVerifies that <code>value_i</code> is the evaluation at <code>x_i</code> of the …\nGenerate a commitment for a polynomial\nExtract the prover parameters from the public parameters.\nExtract the verifier parameters from the public parameters.\nBuild SRS for testing.\nBuild SRS for testing.\nInput a list of multilinear extensions, and a same number …\nOn input a polynomial <code>p</code> and a point <code>point</code>, outputs a proof …\nPrelude\nTrim the universal parameters to specialize the public …\nTrim the universal parameters to specialize the public …\nVerifies that <code>value</code> is the evaluation at <code>x</code> of the …\nArithErrors error {0}\nA commitment is an Affine point.\nInvalid parameters: {0}\nInvalid Proof: {0}\nInvalid Prover: {0}\nInvalid Verifier: {0}\nKZG Polynomial Commitment Scheme on multilinear …\nproof of opening\nProver Parameters\nUniversal Parameter\nVerifier Parameters\nA <code>enum</code> specifying the possible failure modes of the PCS.\nAn error during (de)serialization: {0}\nTranscript error {0}\nbatch proof\nKZG Polynomial Commitment Scheme on univariate polynomial.\nproof of opening\n<code>UnivariateProverParam</code> is used to generate a proof\n<code>UniversalParams</code> are the universal parameters for the KZG10 …\n<code>UnivariateVerifierParam</code> is used to check evaluation proofs …\nVerifies that <code>value_i</code> is the evaluation at <code>x_i</code> of the …\n\\beta times the above generator of G2.\n\\beta times the above generator of G2.\nGenerate a commitment for a polynomial.\nGenerate a commitment for a polynomial Note that the …\nExtract the prover parameters from the public parameters.\nExtract the prover parameters from the public parameters.\nExtract the verifier parameters from the public parameters.\nExtract the verifier parameters from the public parameters.\nf_i(point_i)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\ngenerator for G1\ngenerator of G1\nThe generator of G1.\nBuild SRS for testing.\nBuild SRS for testing.\nBuild SRS for testing. WARNING: THIS FUNCTION IS FOR …\nBuild SRS for testing. WARNING: THIS FUNCTION IS FOR …\ngenerator for G2\ngenerator of G2\nThe generator of G2.\nThe generator of G2.\nh^randomness: h^t1, h^t2, …, <strong>h^{t_nv}</strong>\nh^randomness: h^t1, h^t2, …, <strong>h^{t_nv}</strong>\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the maximum supported degree\nInput a list of multilinear extensions, and a same number …\nnumber of variables\nnumber of variables\nOn input a polynomial <code>p</code> and a point <code>point</code>, outputs a proof …\nOn input a polynomial <code>p</code> and a point <code>point</code>, outputs a proof …\n<code>pp_{0}</code>, <code>pp_{1}</code>, …,pp_{nu_vars} defined by XZZPD19 where …\nGroup elements of the form <code>{ \\beta^i G }</code>, where <code>i</code> ranges …\nParameters\nEvaluation of quotients\nEvaluation of quotients\nprover parameters\nTrim the universal parameters to specialize the public …\nTrim the universal parameters to specialize the public …\nTrim the universal parameters to specialize the public …\nTrim the universal parameters to specialize the public …\nVerifies that <code>value</code> is the evaluation at <code>x</code> of the …\nVerifies that <code>value</code> is the evaluation at <code>x</code> of the …\nStruct for PolyIOP protocol. It has an associated type <code>F</code> …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nArithmetic Error: {0}\nAn IOP proof is a collections of\nInvalid challenge: {0}\nInvalid parameters: {0}\nInvalid Proof: {0}\nInvalid Prover: {0}\nInvalid Verifier: {0}\nPCS error {0}\nA PermutationCheck w.r.t. <code>(fs, gs, perms)</code> proves that (g1, …\nA <code>enum</code> specifying the possible failure modes of the …\nA product-check proves that two lists of n-variate …\nAn error during (de)serialization: {0}\nShould not arrive to this point\nTrait for doing sum check protocols.\nTranscript Error: {0}\nA ZeroCheck for <code>f(x)</code> proves that <code>f(x) = 0</code> for all …\nExtract sum from the proof\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitialize the system with a transcript\nInitialize the system with a transcript\nInitialize the system with a transcript\nInitialize the system with a transcript\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInputs:\nProves that two lists of n-variate multilinear polynomials …\nGenerate proof of the sum of polynomial over {0,1}^<code>num_vars</code>\ninitialize the prover to argue for the sum of polynomial …\nTakes as input a struct, and converts them to a series of …\nVerify that (g1, …, gk) is a permutation of (f1, …, …\nVerify that for witness multilinear polynomials (f1, …, …\nVerify the claimed sum using the proof\nverify the claimed sum using the proof")